---
title: "RNA-seq analysis on public data"
author: "Carmen Navarro"
date: "2021-02-05"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
bibliography: /home/carmen/work/publications/hesc-epigenomics/data/meta/biblio.bib
params:
  datadir: ./data
  rnaseqdir: ./data/rnaseq/
  length_cutoff: 10000
  value_cutoff: 0.01
  deciding_stat: "FPKM"
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
library(wigglescout)
library(ggplot2)
library(knitr)
library(ggvenn)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(rtracklayer)
library(GenomicRanges)
library(purrr)
library(xfun)
library(cowplot)
library(tidyr)
library(gprofiler2)
library(EnsDb.Hsapiens.v86)

source("./code/globals.R")

knitr::opts_chunk$set(dev = c('png', 'svg'))
```

# Summary

**Data**: Used public data from [@collier2017]: H9 embryonic stem cells in Naïve and Primed state, three biological replicates.

```{r sample-table, results="asis", echo=FALSE}
samples_file <- file.path(params$datadir, "meta", "Kumar_2020_public_data_plus_layout.csv")

samples <- read.table(samples_file, header = T, sep=",")
# 
samples <- samples[samples$dataset_id == "Collier_2017", ]
kable(samples, caption="Sample info")
```

# Primary analysis

RNA-seq data was analysed by a standard RNA-seq pipeline v2.0, available on nf-core [@ewels2019nf] with mostly default settings. For more information about the specific steps involved in this analysis, refer to the repository documentation: <https://nf-co.re/rnaseq/2.0>.

## Reference genome

Due to some difficulties in using `hg38` with iGenomes, and since the rest of the analysis has been done on such reference (more specifically, GRCh38.p12). An annotation was downloaded from Ensembl and used as matching custom `--fasta` and `--gtf` parameters:

<ftp://ftp.ensembl.org/pub/release-95/gtf/homo_sapiens/Homo_sapiens.GRCh38.95.gtf.gz>

<ftp://ftp.ensembl.org/pub/release-95/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz>

## Running environment

RNA-seq analysis was run on Uppmax HPC environment using standard parameters: `nextflow run nf-core/rnaseq -profile uppmax -revision 2.0 --public_data_ids ids_file.txt`. `ids_file.txt` contained only the GSM ids as plain text.

This run would produce the corresponding FASTQ files and then a further run with the generated `samplesheet_grouped.tsv` file, the pipeline was run.

## Note on pipeline version

There is a newer RNA-seq version: <https://github.com/nf-core/rnaseq/releases/tag/3.0>. This affects the quantification, so it may be the case that results are better using Salmon instead of featureCounts. However at this point there is a problem with Singularity on Uppmax and this version cannot be easily run. If necessary, I will re-do this analysis in the future, once these problems are solved.

# Downstream analysis

## Helper functions

```{r helper, warning=FALSE}
color_list <- c(Naive=global_palette$teal,
                Primed=global_palette$coral)

#' Select by quantile
#'
#' @param counts Counts table.
#' @param length_cutoff Gene length cutoff.
#' @param value_cutoff Value cutoff
#' @param min_q Minimum quantile to consider
#' @param max_q Maximum quantile to consider
#' @param field Which field to use (default = TPM).
#'
#' @return filtered data.frame
quantile_group <- function(counts, min_q, max_q, value_cutoff = 0, length_cutoff = 10000, field = "TPM") {
  counts$length <- (counts$End - counts$Start)
  counts <- dplyr::filter(counts, .data[[field]] > value_cutoff & length > length_cutoff)
  
  q <- quantile(counts[, field], probs = c(min_q, max_q))
  
  dplyr::filter(counts, .data[[field]] >= q[1] & .data[[field]] <= q[2])
}

#' Make a venn diagram out ouf a list of selected gene counts
#'
#' @param gene_counts of count tables
#' @param title Plot title
#' @param color Base color

#' @return ggplot object
genes_venn <- function(gene_counts, title, color) {
  field_list <- list(r1 = gene_counts[[1]]$Gene.Name, 
                     r2 = gene_counts[[2]]$Gene.Name,
                     r3 = gene_counts[[3]]$Gene.Name)
  
  clist <- rep(color, 3)
  ggvenn(field_list, fill_color = clist, fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle(title)
}

intersect_genes_3 <- function(glist) {
  intersect(intersect(glist[[1]]$Gene.Name, 
                             glist[[2]]$Gene.Name),
                             glist[[3]]$Gene.Name)
}

#' Subset a named granges by name
#'
#' @param names Names list
#' @param granges GRanges to subset.
#'
#' @return GRanges
select_genes <- function(names, granges) {
  sort(granges[granges$name %in% names, ])
}

#' Get GRanges with gene symbols for hg38
#'
#' @return A GRanges where name field is Gene symbol
genes_hg38 <- function() {
  # This matches gene IDs to symbols
  x <- org.Hs.egSYMBOL
  
  # Get the gene names that are mapped to an entrez gene identifier
  mapped_genes <- mappedkeys(x)
  # Convert to a list
  xx <- as.list(x[mapped_genes])
  
  # Apparently there are some pathway crap that puts NAs in the list
  xx <- xx[!is.na(xx)]
  
  gene_id_to_name <- unlist(xx)
  
  genes <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
  genes$name <- gene_id_to_name[genes$gene_id]
  genes
}

#' Get GRanges with gene symbols for hg38
#'
#' @return A GRanges where name field is Gene symbol
genes_hg38_ensembl <- function() {
  # This matches gene IDs to symbols
  edb <- EnsDb.Hsapiens.v86
  genes(edb)
}

export_gene_set <- function(replicates, name, path, annot_func, name_field) {
  gene_names <- intersect_genes_3(replicates)
  
  genes_all <- annot_func()
  genes_all <- genes_all[, name_field]
  names(mcols(genes_all)) <- "name"
  
  result <- select_genes(gene_names, genes_all)
  
  out_file <- file.path(path, name)
  export(result, out_file)
}

```

## Gene counts

Gene counts output file from `featureCounts` are used.

```{r counts-example, results="asis"}
counts_file <- file.path(params$rnaseqdir,
                         "Collier_2017_featurecounts.tsv")

counts <- read.table(counts_file, sep = "\t", header = T)
kable(head(counts))
```

### Counts distribution

```{r counts-hist}

counts_long <- pivot_longer(counts,
                            cols = -c(Geneid, gene_name),
                            names_to = c("sample", "replicate"),
                            names_sep = "_",
                            values_to = "count",
                            names_ptypes = list(sample = factor(),
                                                replicate = factor()))

color_scale <- scale_color_manual(name = "sample",
                                  values = unlist(color_list))


ggplot(counts_long,
       aes(x = interaction(sample, replicate, lex.order =T),
           y = count, color = sample)) + 
  labs(x = "Sample", y = "counts",
     title = "featureCounts distribution per sample") +
  geom_boxplot() +  
  color_scale + 
  theme_default()

```

Log scaled + 1:

```{r counts-hist-log}
library(tidyr)
counts_long <- pivot_longer(counts,
                            cols = -c(Geneid, gene_name),
                            names_to = c("sample", "replicate"),
                            names_sep = "_",
                            values_to = "count",
                            names_ptypes = list(sample = factor(),
                                                replicate = factor()))

color_scale <- scale_color_manual(name = "sample",
                                  values = unlist(color_list))


ggplot(counts_long,
       aes(x = interaction(sample, replicate, lex.order =T),
           y = log10(count+1), color = sample)) + 
  geom_boxplot() +  
  color_scale + 
  labs(x = "Sample", y = "log10(counts + 1)",
       title = "featureCounts distribution per sample") +
  theme_default()

```

As expected, there are many zero values in all the distributions, and long tails since there is no upper limit in RNA-seq data.

## Stringtie output

`stringtie` [@kovaka2019transcriptome] <https://ccb.jhu.edu/software/stringtie/>) is a tool for quantitation of full-length transcripts (taking variants into account) per gene.

This output is also provided as standard output for RNA-seq pipeline v2.0.

```{r results="asis"}
stringtie_files <- list(
  naive = list.files(params$rnaseqdir,
                     pattern = "Naive.*gene_abundance.txt", full.names = T),
  primed = list.files(params$rnaseqdir,
                      pattern = "Primed.*gene_abundance.txt", full.names = T)
)

kable(head(read.csv(stringtie_files$primed[1], header = T, sep = "\t")))
```

### Gene expression groups

To get sets of high - med -low expressed:

1\. Remove genes that are shorter than 10kb.

2\. Take top 5%, around-median 5% and lowest 5% genes.

In this case, we have 3 biological replicates per condition.

So one possible approach is do this per replicate and see how they intersect.

```{r categorize-genes}

counts_naive <- lapply(stringtie_files$naive,
                       read.csv,
                       header = T,
                       sep = "\t")

counts_primed <- lapply(stringtie_files$primed,
                        read.csv,
                        header = T,
                        sep = "\t")

# Size of the quantile group
size = 0.1

min_qs <- c(0, 0.5 - (size/2), 1-size)
max_qs <- c(0+size, 0.5 + (size/2), 1)

quantile_low <- purrr::partial(
  quantile_group,
  min_q = min_qs[1],
  max_q = max_qs[1],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = params$deciding_stat
)

quantile_med <- purrr::partial(
  quantile_group,
  min_q = min_qs[2],
  max_q = max_qs[2],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = params$deciding_stat
)

quantile_high <- purrr::partial(
  quantile_group,
  min_q = min_qs[3],
  max_q = max_qs[3],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = params$deciding_stat
)

naive_top <- map(counts_naive, quantile_high)
naive_med <- map(counts_naive, quantile_med)
naive_low <- map(counts_naive, quantile_low)

primed_top <- map(counts_primed, quantile_high)
primed_med <- map(counts_primed, quantile_med)
primed_low <- map(counts_primed, quantile_low)

c <- color_list[["Naive"]]
```

#### Naïve expressed gene groups

Top expressed genes:

```{r top-naive-genes-venn-replicates, fig.width = 8, fig.height = 8}
genes_venn(naive_top,
           "Naïve top expressed genes across replicates",
           color = c)
```

Medium expressed genes:

```{r med-naive-genes-venn-replicates, fig.width = 8, fig.height = 8}
genes_venn(naive_med,
           "Naïve med expressed genes across replicates",
           color = c)
```

Low expressed genes:

```{r low-naive-genes-venn-replicates, fig.width = 8, fig.height = 8}
genes_venn(naive_low,
           "Naïve low expressed genes across replicates",
           color = c)
```

#### Primed expressed gene groups

```{r top-primed-genes-venn-replicates, fig.width = 8, fig.height = 8}
c <- color_list[["Primed"]]

genes_venn(primed_top,
           "Primed top expressed genes across replicates",
           color = c)
```

```{r med-primed-genes-venn-replicates, fig.width = 8, fig.height = 8}
genes_venn(primed_med,
           "Primed med expressed genes across replicates",
           color = c)
```

```{r bottom-primed-genes-venn-replicates, fig.width = 8, fig.height = 8}
genes_venn(primed_low,
           "Primed low expressed genes across replicates",
           color = c)
```


#### Primed vs Naive 

I assume here there should be some overlap

```{r naive-vs-primed-venn, fig.width = 8, fig.height = 8}
naive_top_genes <- intersect_genes_3(naive_top)
primed_top_genes <- intersect_genes_3(primed_top)

field_list <- list(naive=naive_top_genes,
                   primed=primed_top_genes)

ggvenn(field_list, fill_color = c(color_list[["Naive"]], color_list[["Primed"]]), fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle("Naive vs primed top expressed genes")

```

#### TPM vs FPKM

There is maximum overlap in the top genes. On the lower side, they tend to 
disagree more.

```{r naive-tpm-vs-fpkm, fig.width = 8, fig.height = 8}
quantile_high_tpm <- purrr::partial(
  quantile_group,
  min_q = min_qs[3],
  max_q = max_qs[3],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = "TPM"
)

quantile_high_fpkm <- purrr::partial(
  quantile_group,
  min_q = min_qs[3],
  max_q = max_qs[3],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = "FPKM"
)

naive_top_fpkm <-  intersect_genes_3(map(counts_naive, quantile_high_fpkm))
naive_top_tpm <-  intersect_genes_3(map(counts_naive, quantile_high_tpm))


field_list <- list(fpkm=naive_top_fpkm,
                   tpm=naive_top_tpm)

ggvenn(field_list, fill_color = c(color_list[["Naive"]], color_list[["Naive"]]), fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle("Naive top expressed genes (TPM vs FPKM)")

```


```{r primed-tpm-vs-fpkm, fig.width = 8, fig.height = 8}
primed_top_fpkm <-  intersect_genes_3(map(counts_primed, quantile_high_fpkm))
primed_top_tpm <-  intersect_genes_3(map(counts_primed, quantile_high_tpm))

field_list <- list(fpkm=primed_top_fpkm,
                   tpm=primed_top_tpm)

ggvenn(field_list, fill_color = c(color_list[["Primed"]], color_list[["Primed"]]), fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle("Primed top expressed genes (TPM vs FPKM)")

```

```{r naive-low-tpm-vs-fpkm, fig.width = 8, fig.height = 8}

quantile_tpm <- purrr::partial(
  quantile_group,
  min_q = min_qs[1],
  max_q = max_qs[1],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = "TPM"
)

quantile_fpkm <- purrr::partial(
  quantile_group,
  min_q = min_qs[1],
  max_q = max_qs[1],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = "FPKM"
)

naive_low_fpkm <-  intersect_genes_3(map(counts_naive, quantile_fpkm))
naive_low_tpm <-  intersect_genes_3(map(counts_naive, quantile_tpm))

field_list <- list(fpkm=naive_low_fpkm,
                   tpm=naive_low_tpm)

ggvenn(field_list, fill_color = c(color_list[["Naive"]], color_list[["Naive"]]), fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle("Naive low expressed genes (TPM vs FPKM)")

```


```{r primed-low-tpm-vs-fpkm, fig.width = 8, fig.height = 8}

primed_low_fpkm <-  intersect_genes_3(map(counts_primed, quantile_fpkm))
primed_low_tpm <-  intersect_genes_3(map(counts_primed, quantile_tpm))

field_list <- list(fpkm=primed_low_fpkm,
                   tpm=primed_low_tpm)

ggvenn(field_list, fill_color = c(color_list[["Primed"]], color_list[["Primed"]]), fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle("Primed low expressed genes (TPM vs FPKM)")

```

## Gene set enrichment

```{r go-enrichment, fig.width = 8, fig.height = 8}
naive_only <- setdiff(naive_top_genes, primed_top_genes)
primed_only <- setdiff(primed_top_genes, naive_top_genes)
both <- intersect(naive_top_genes, primed_top_genes)

genes <- list(naive_only = naive_only,
              primed_only = primed_only,
              shared = both)

# Do a gprofiler analysis
gostres <- gost(query = genes, 
                organism = "hsapiens", ordered_query = FALSE, 
                multi_query = FALSE, significant = TRUE, exclude_iea = FALSE, 
                measure_underrepresentation = FALSE, evcodes = FALSE, 
                user_threshold = 0.05, correction_method = "g_SCS", 
                domain_scope = "annotated", custom_bg = NULL, 
                numeric_ns = "", sources = NULL, as_short_link = FALSE)

gostplot(gostres, capped = TRUE, interactive = TRUE)
```

This is a bit too much at the moment, we can probably refine this.

## Annotation of gene groups 

Now I annotate the intersection of these sets in the reference genome, to be able to look at chromatin marks there.

```{r annotate-groups, echo=FALSE, warning=FALSE, message=FALSE}

export_gene_set(naive_top, "Naive_top.bed", "./output/Collier_2017", genes_hg38, "name")
export_gene_set(naive_med, "Naive_med.bed", "./output/Collier_2017", genes_hg38, "name")
export_gene_set(naive_low, "Naive_low.bed", "./output/Collier_2017", genes_hg38, "name")

export_gene_set(naive_top, "Naive_top.bed", "./output/Collier_2017/ensembl", genes_hg38_ensembl, "gene_name")
export_gene_set(naive_med, "Naive_med.bed", "./output/Collier_2017/ensembl", genes_hg38_ensembl, "gene_name")
export_gene_set(naive_low, "Naive_low.bed", "./output/Collier_2017/ensembl", genes_hg38_ensembl, "gene_name")

export_gene_set(primed_top, "Primed_top.bed", "./output/Collier_2017", genes_hg38, "name")
export_gene_set(primed_med, "Primed_med.bed", "./output/Collier_2017", genes_hg38, "name")
export_gene_set(primed_low, "Primed_low.bed", "./output/Collier_2017", genes_hg38, "name")

export_gene_set(primed_top, "Primed_top.bed", "./output/Collier_2017/ensembl", genes_hg38_ensembl, "gene_name")
export_gene_set(primed_med, "Primed_med.bed", "./output/Collier_2017/ensembl", genes_hg38_ensembl, "gene_name")
export_gene_set(primed_low, "Primed_low.bed", "./output/Collier_2017/ensembl", genes_hg38_ensembl, "gene_name")


```

### Download BED files

```{r download-files, echo=FALSE}
xfun::embed_dir(file.path("./output/Collier_2017"))
```


### RNA-seq bigwig signal at selected groups

This is sort of a validation of the groups I get:

```{r rnaseq-boxplot-groups-panel, fig.width=11, fig.height=16, warning = F}
export_dir <- "./output/Collier_2017/ensembl/"
bedfiles_top <- list.files(export_dir, full.names = T, pattern = "_top")
bedfiles_med <- list.files(export_dir, full.names = T, pattern = "_med")
bedfiles_bottom <- list.files(export_dir, full.names = T, pattern = "_low")

# Ensures proper order
bedfiles <- c(bedfiles_top, bedfiles_med, bedfiles_bottom)
bwsignal <- list.files(file.path(params$datadir, "bw/Collier_2017"), full.names = T)

colors <- c(rep(color_list[["Naive"]], 3), rep(color_list[["Primed"]], 3))
# labels <- style_info[basename(c(bwsignal, bwinput)), "label"]

# Use tss for this
tss_window <- 2500

bed_ranges <- lapply(bedfiles, import)

# Take just downstream from TSS
tss_ranges <- lapply(bed_ranges, promoters, upstream = 0, downstream = tss_window)

this_plot <- partial(bw_loci, bwfiles = bwsignal)
# 
plots <- purrr::map(tss_ranges, this_plot)
names(plots) <- basename(bedfiles)

# Pivot 1 item:
library(tidyr)

pivot_bed <- function(granges, loci_name) {
  bin_ids <- c("seqnames", "start", "end", "width", "strand")
  pivoted <- pivot_longer(data = data.frame(granges),
                             cols = contains("_R"),
                             names_to = "sample",
                             values_to = "value")
  pivoted[["group"]] <- loci_name
  pivoted
}

pivoted_list <- map2(plots, names(plots), pivot_bed)
all_vals <- do.call(rbind, pivoted_list)

ggplot(all_vals, aes(x = sample, y = log2(value), color = sample, group = sample)) + geom_boxplot() + facet_wrap(group ~ .)  + theme_default() + theme(axis.text.x = element_text(angle=45, hjust = 1)) + scale_color_manual(name = "sample", values = colors)
```

Profile is not very informative, I think.

```{r rnaseq-profile-groups-panel, fig.width=11, fig.height=16, warning = F}
# Need to match ref names and so on -> ENSEMBL
export_dir <- "./output/Collier_2017/ensembl/"
bedfiles_top <- list.files(export_dir, full.names = T, pattern = "_top")
bedfiles_med <- list.files(export_dir, full.names = T, pattern = "_med")
bedfiles_bottom <- list.files(export_dir, full.names = T, pattern = "_low")

# Ensures proper order
bedfiles <- c(bedfiles_top, bedfiles_med, bedfiles_bottom)
bwsignal <- list.files(file.path(params$datadir, "bw/Collier_2017"), full.names = T)

colors <- c(rep(color_list[["Naive"]], 3), rep(color_list[["Primed"]], 3))

up <- 500
dw <- 500
bs <- 500
md <- "stretch"

this_plot <- partial(plot_bw_profile, bwfiles = bwsignal,
                     bin_size = bs,
                     mode = md,
                     upstream = up,
                     downstream = dw,
                     colors = colors,
                     verbose = TRUE)

plots <- purrr::map(bedfiles, this_plot)

plots[[1]] <- plots[[1]] + ggtitle("RNA-seq per gene class: Naive")
plots[[2]] <- plots[[2]] + ggtitle("- Primed")

plot_grid(plotlist=plots, nrow=3)
```



## Bibliography

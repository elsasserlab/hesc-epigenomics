---
title: "Genome annotations"
author: "Carmen Navarro"
date: "2021-03-21"
output:
  workflowr::wflow_html:
    code_folding: show
editor_options:
  chunk_output_type: console
bibliography: /home/carmen/work/publications/hesc-epigenomics/data/meta/biblio.bib
params:
  datadir: ./data/
  outbins: ./data/bed/Kumar_2020/bins_stats
  outgenes: ./data/bed/Kumar_2020/gene_stats
  pval_cutoff: 0.05
  fc_cutoff: 1
  bin_size: 10000
  length_cutoff: 500
  value_cutoff: 0.01
  deciding_stat: "TPM"
---

# Summary

This notebook shows how the genome annotations relevant for this publication
were calculated. 

* **Gene annotation**: Genes obtained from UCSC `hg38`.
* [**Bivalent genes**](../data/bed/Kumar_2020/Court_2017_bivalent_genes.bed): Genes from UCSC `hg38` overlapping with bivalent peaks from [@court2017annotated].
* **Differential TSS per histone mark**: [H2AUb](../data/bed/Kumar_2020/gene_stats/Kumar_2020_H2Aub_diff_tss.bed) and [H3K4m3](../data/bed/Kumar_2020/gene_stats/Kumar_2020_H3K4m3_diff_tss.bed) +/- 1500 bp used. [H3K27m3](../data/bed/Kumar_2020/gene_stats/Kumar_2020_H3K27m3_diff_tss.bed): +/- 2500bp used, as this is a broader mark. DESeq2 [@love2014moderated] was used ad-hoc for our Minute-ChIP data. See deseq_functions.R for more details. Naïve condition was used as reference for enrichment / depletion. Genes were selected if adjusted 
p value from DESeq2 was lower than `r params$pval_cutoff` and absolute value of log2 fold change was > `r params$fc_cutoff`. A separate annotation was created for genes selected by this procedure that overlapped with **bivalent genes**: [H2AUb](../data/bed/Kumar_2020/gene_stats/Kumar_2020_H2Aub_diff_bivalent.bed), [H3K4m3](../data/bed/Kumar_2020/gene_stats/Kumar_2020_H3K4m3_diff_bivalent.bed), [H3K27m3](../data/bed/Kumar_2020/gene_stats/Kumar_2020_H3K27m3_diff_bivalent.bed).
* **Differential `r params$bin_size` bp bins per histone mark**: DESeq2 was used in the same way as differential TSS. Bins were selected by p-value only. These results are cached and / or skipped in this notebook because this is a very memory-demanding step: [H2AUb](../data/bed/Kumar_2020/bins_stats/Kumar_2020_H2AUb_signif_ni_05.bed), [H3K4m3](../data/bed/Kumar_2020/bins_stats/Kumar_2020_H3K4m3_signif_ni_05.bed), [H3K27m3](../data/bed/Kumar_2020/bins_stats/Kumar_2020_H3K27m3_signif_ni_05.bed).

* **Gene expression groups**: Our RNA-seq data was used to select top-med-low groups of genes by expression. Genes
were pre-filtered by transcript length (> `r params$length_cutoff`) and minimum `r params$deciding_stat` (`r params$value_cutoff`) and top, med and low 10% of genes were retained per replicate. Genes were annotated to each of these categories if they appeared in all three replicates within the given range. Downloads: Naïve [top](../data/bed/Kumar_2020/Kumar_2020_Naive_top.bed), [med](../data/bed/Kumar_2020/Kumar_2020_Naive_med.bed) and [low](../data/bed/Kumar_2020/Kumar_2020_Naive_low.bed). Primed [top](../data/bed/Kumar_2020/Kumar_2020_Primed_top.bed), [med](../data/bed/Kumar_2020/Kumar_2020_Primed_med.bed) and [low](../data/bed/Kumar_2020/Kumar_2020_Primed_low.bed).
* **Differentially expressed genes**: Our RNA-seq data was analysed with DESeq2 to obtain Naïve vs. Primed differentially expressed genes. Genes were selected if adjusted p value from DESeq2 was lower than `r params$pval_cutoff` and absolute value of log2 fold change was > `r params$fc_cutoff`. Downloads: [Naïve_up](../data/bed/Kumar_2020/Kumar_2020_Naive_down_05_logfc1.bed), [Naïve_down](../data/bed/Kumar_2020/Kumar_2020_Naive_up_05_logfc1.bed).


* [**Master gene table**](../data/bed/Kumar_2020_gene_annotation_table.tsv). All gene-specific annotations above are summarized in a gene table. Each gene along with their locus has a column for each histone mark and also expression data.


```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(wigglescout)
library(ggplot2)
library(knitr)
library(ggvenn)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(org.Hs.eg.db)
library(rtracklayer)
library(GenomicRanges)
library(purrr)
library(xfun)
library(cowplot)
library(tidyr)
library(DESeq2)

source("./code/ucsc_annotations.R")
source("./code/deseq_functions.R")
source("./code/embed_functions.R")
source("./code/globals.R")

knitr::opts_chunk$set(dev = c('png', 'svg'))
knitr::opts_chunk$set(class.source='fold-show')
```

# Helper functions

```{r helper-functions, class.source = NULL}
#' Select DESeq results by pval and fc cutoff and returns GRanges
#'
#' @param diff_lfc Results dataframe
#' @param loci Corresponding GRanges
#' @param p_cutoff Pvalue cutoff
#' @param fc_cutoff Fold change cutoff
#'
#' @return GRanges with filtered elements
select_signif <- function(diff_lfc, loci, p_cutoff = 0.05, fc_cutoff = 1) {
  diff_lfc <- diff_lfc[!is.na(diff_lfc$padj), ]
  signif_tss <- diff_lfc[diff_lfc$padj <= p_cutoff & abs(diff_lfc$log2FoldChange) > fc_cutoff, ]

  mcols(loci) <- NULL
  signif_gr <- loci[as.numeric(rownames(signif_tss)), ]
  signif_gr$score <- signif_tss$log2FoldChange
  signif_gr
}

select_groups <- function(diff_lfc, loci, p_cutoff = 0.05, fc_cutoff = 1, mean_cutoff = 10) {
  # Here I don't want to discard the NAs as they will go to the unenriched group. I
  # replace those with a 1
  diff_lfc[is.na(diff_lfc$padj), "padj"] <- 1
  
  signif_up_tss <- diff_lfc[diff_lfc$padj <= p_cutoff & diff_lfc$log2FoldChange > fc_cutoff, ]
  signif_down_tss <- diff_lfc[diff_lfc$padj <= p_cutoff & diff_lfc$log2FoldChange < -fc_cutoff, ]
  
  always_up <- diff_lfc[diff_lfc$baseMean > mean_cutoff, ]
  
  mcols(loci) <- NULL
  signif_gr <- loci[as.numeric(rownames(signif_tss)), ]
  signif_gr$score <- signif_tss$log2FoldChange
  signif_gr
}


#' Intersect 3 gene results by gene name
#'
#' @param glist List of gene results
#' @param field Field used to intersect
#'
#' @return A list of intersecting elements
intersect_genes_3 <- function(glist, field = "gene_id") {
  intersect(intersect(glist[[1]][[field]], 
                      glist[[2]][[field]]),
                      glist[[3]][[field]])
}

#' Subset a named granges by name
#'
#' @param names Names list
#' @param granges GRanges to subset.
#'
#' @return GRanges
select_genes <- function(names, granges) {
  sort(granges[granges$name %in% names, ])
}

#' Export genes that overlap in a set of replicates (3)
#'
#' @param replicates Gene counts results list
#' @param path Output file
export_gene_set <- function(replicates, path) {
  gene_names <- intersect_genes_3(replicates)
  genes_all <- genes_hg38()
  genes_all <- genes_all[, "name"]

  result <- select_genes(gene_names, genes_all)
  export(result, path)
}

#' Select by quantile
#'
#' @param counts Counts table.
#' @param length_cutoff Gene length cutoff.
#' @param value_cutoff Value cutoff
#' @param min_q Minimum quantile to consider
#' @param max_q Maximum quantile to consider
#' @param field Which field to use (default = TPM).
#'
#' @return filtered data.frame
quantile_group <- function(counts, min_q, max_q,
                           value_cutoff = 0,
                           length_cutoff = 500,
                           field = "TPM") {

    counts <- dplyr::filter(counts, .data[[field]] > value_cutoff &
                            length > length_cutoff)
    
    q <- quantile(counts[, field], probs = c(min_q, max_q))
    dplyr::filter(counts, .data[[field]] >= q[1] & .data[[field]] <= q[2])
}



rsem_deseq_analysis <- function(counts_file, c1_columns, c2_columns, c1_name, c2_name, reference, alpha = 0.05) {
  if (! reference %in% c(c1_name, c2_name)) {
    stop(paste(reference, "must be", c1_name, "or", c2_name))
  }
  
  counts <- read.table(counts_file, sep = "\t", header = T)
  
  columns <- c(c1_columns, c2_columns)
  
  samples <- data.frame(row.names = columns, condition = factor(c(rep(c1_name, length(c1_columns)), rep(c2_name, length(c2_columns)))))
  samples$condition <- relevel(samples$condition, ref = reference)
  
  counts_only <- round(counts[, columns])
  rownames(counts_only) <- counts$gene_id
  
  dds <- DESeqDataSetFromMatrix(countData = counts_only,
                                colData = samples,
                                design = ~ condition)
  dds <- DESeq(dds)
  res <- results(dds, alpha=alpha)
  res
}

ni_pr_expression_analysis <- function(datadir, alpha = 0.05) {
  counts_file <- file.path(datadir, "rnaseq/Kumar_2020/rsem.merged.gene_counts.tsv")
  c1_columns <- paste("Kumar_2020_Naive", c("R1", "R2", "R3"), sep = "_")
  c2_columns <- paste("Kumar_2020_Primed", c("R1", "R2", "R3"), sep = "_")
  rsem_deseq_analysis(counts_file, c1_columns, c2_columns, "Naive", "Primed", "Naive", alpha)
}

ni_ezh2i_expression_analysis <- function(datadir, alpha = 0.05) {
  counts_file <- file.path(datadir, "rnaseq/Kumar_2020/rsem.merged.gene_counts.tsv")
  c1_columns <- paste("Kumar_2020_Naive", c("R1", "R2", "R3"), sep = "_")
  c2_columns <- paste("Kumar_2020_Naive_EZH2i", c("R1", "R2", "R3"), sep = "_")
  rsem_deseq_analysis(counts_file, c1_columns, c2_columns, "Naive", "EZH2i", "Naive", alpha)
}

pr_ezh2i_expression_analysis <- function(datadir, alpha = 0.05) {
  counts_file <- file.path(datadir, "rnaseq/Kumar_2020/rsem.merged.gene_counts.tsv")
  c1_columns <- paste("Kumar_2020_Primed", c("R1", "R2", "R3"), sep = "_")
  c2_columns <- paste("Kumar_2020_Primed_EZH2i", c("R1", "R2", "R3"), sep = "_")
  rsem_deseq_analysis(counts_file, c1_columns, c2_columns, "Naive", "EZH2i", "Naive", alpha)
}


make_df <- function(diffres, name_suffix) {
  df <- data.frame(diffres)
  colnames(df) <- paste(colnames(df), name_suffix, sep = "_")
  df$gene <- rownames(df)
  df
}


```


# Gene annotation

Gene annotation is obtained from UCSC hg38 annotation. 
```{r get-hg38-genes}
genes <- genes_hg38()
```

Only genes that have a gene symbol associated to it are kept, leaving a set
of `r length(genes)`.

Download `r embed_df(data.frame(genes), "hg38_genes.bed", "gene annotation")`.

## Bivalent genes by name

Bivalent genes are obtained from UCSC hg38 annotation using as names the ones
in [@court2017annotated] supplementary table. 

```{r get-bivalent-genes}
gene_file <- file.path(params$datadir, "meta/Court_2017_gene_names_uniq.txt")
gene_list <- read.table(gene_file, header=F)
colnames(gene_list) <- c("name")

biv_genes_name <- get_genes_by_name(gene_list$name)
```

From the list of `r length(gene_list$name)` gene names from
[@court2017annotated], `r length(unique(biv_genes_name))` unique genomic loci are
successfully retrieved.

Download `r embed_df(data.frame(biv_genes_name), "bivalent_genes.bed", "bivalent gene annotation")`.

Download `r embed_df(gene_list, "genes.txt", "genes list")`.

## Bivalent genes by overlap

Bivalent genes are obtained from overlap of hg38-liftovered from original 
[@court2017annotated] genes with UCSC hg38 annotation.

```{r get-bivalent-genes-overlap}
gene_file <- file.path(params$datadir, "bed/Bivalent_Court2017.hg38.bed")
gene_loci <- import(gene_file)

biv_genes_overlap <- get_genes_by_overlap(gene_loci)

export(biv_genes_overlap, "./data/bed/Kumar_2020/Court_2017_bivalent_genes.bed")
```

From the list of `r length(gene_list$name)` gene names from
[@court2017annotated], `r length(unique(biv_genes_overlap))` unique genomic loci are
successfully retrieved.

Download `r embed_df(data.frame(biv_genes_overlap), "bivalent_genes.bed", "bivalent gene annotation")`.


## Match between both

```{r venn-names}

field_list <- list(names = biv_genes_name$name, overlap = biv_genes_overlap$name)
ggvenn(field_list, fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle("Names vs location")

```

Some of the names cases are: either the gene has not been annotated because 
locus is proximal to annotation but not overlapping it (this may be because
of lift over of coordinates), or because the name from UCSC hg38 annotation
does not match the name in Court 2017 original annotated gene name.

# H3K27m3 differential TSS

```{r all-genes-tss-k27-diff, warning=F, message=F}
bw_cond_1 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K27m3_H9_Ni_rep[1-3].hg38.scaled.bw"
  )
bw_cond_2 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K27m3_H9_Pr_rep[1-3].hg38.scaled.bw"
  )

all_hg38_genes <- genes_hg38()
tss <- promoters(all_hg38_genes, upstream = 2500, downstream = 2500)
mcols(tss) <- NULL

c1 <- bw_loci(bw_cond_1, tss)
c2 <- bw_loci(bw_cond_2, tss)

diff <- bw_granges_diff_analysis(c1, c2, "Naive", "Primed", estimate_size_factors = FALSE)

diff_lfc <- lfcShrink(diff, coef="condition_Primed_vs_Naive", type="apeglm")
diff <- results(diff, alpha = params$pval_cutoff)

plotMA(diff_lfc)

signif_gr <- select_signif(diff, c1, p_cutoff = params$pval_cutoff)
hits <- findOverlaps(signif_gr, all_hg38_genes)
signif_gr_w_name <- signif_gr
signif_gr_w_name$name <- "None"
signif_gr_w_name[queryHits(hits), ]$name <- all_hg38_genes[subjectHits(hits), ]$name

# I need: Naive >> Primed, Primed >> Naive, Always high, always low.

export(signif_gr_w_name, file.path(params$outgenes, "Kumar_2020_H3K27m3_diff_tss.bed"))

# Select bivalent ones
signif_gr_biv <- subsetByOverlaps(signif_gr_w_name, biv_genes_overlap)
export(signif_gr_biv, file.path(params$outgenes, "Kumar_2020_H3K27m3_diff_bivalent.bed"))
```

## Bivalent

```{r biv-genes-tss-k27-diff, warning=F, message=F}
biv_genes <- biv_genes_overlap
tss <- promoters(biv_genes, upstream = 2500, downstream = 2500)
mcols(tss) <- NULL

c1 <- bw_loci(bw_cond_1, tss)
c2 <- bw_loci(bw_cond_2, tss)

diff <- bw_granges_diff_analysis(c1, c2, "Naive", "Primed", estimate_size_factors = FALSE)
diff_lfc <- lfcShrink(diff, coef="condition_Primed_vs_Naive", type="apeglm")
diff <- results(diff, alpha = params$pval_cutoff)
plotMA(diff_lfc)

signif_gr <- select_signif(diff, c1, p_cutoff = params$pval_cutoff)

# export(signif_gr, "./data/bed/Kumar_2020_H3K27m3_diff_tss_bivalent.bed")
```

## Compare
```{r venn-global-vs-local}

global <- import(file.path(params$outgenes, "Kumar_2020_H3K27m3_diff_bivalent.bed"))
local <- subsetByOverlaps(biv_genes_overlap, signif_gr)
field_list <- list(global = global$name, local = local$name)
ggvenn(field_list, fill_alpha = 0.5, text_size = 5, stroke_color = "#ffffff") + 
    ggtitle("Global vs local")

```

# H2Aub differential TSS

```{r all-genes-tss-h2aub-diff, warning=F, message=F}
bw_cond_1 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H2Aub_H9_Ni_rep[1-3].hg38.scaled.bw"
  )
bw_cond_2 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H2Aub_H9_Pr_rep[1-3].hg38.scaled.bw"
  )

all_hg38_genes <- genes_hg38()
tss <- promoters(all_hg38_genes, upstream = 1500, downstream = 1500)
mcols(tss) <- NULL

c1 <- bw_loci(bw_cond_1, tss)
c2 <- bw_loci(bw_cond_2, tss)

diff <- bw_granges_diff_analysis(c1, c2, "Naive", "Primed", estimate_size_factors = FALSE)
diff_lfc <- lfcShrink(diff, coef="condition_Primed_vs_Naive", type="apeglm")

diff <- results(diff, alpha = params$pval_cutoff)
plotMA(diff_lfc)

signif_gr <- select_signif(diff, c1, p_cutoff = params$pval_cutoff)

hits <- findOverlaps(signif_gr, all_hg38_genes)
signif_gr_w_name <- signif_gr
signif_gr_w_name$name <- "None"
signif_gr_w_name[queryHits(hits), ]$name <- all_hg38_genes[subjectHits(hits), ]$name
export(signif_gr_w_name, file.path(params$outgenes, "Kumar_2020_H2Aub_diff_tss.bed"))

# Select bivalent ones
signif_gr_biv <- subsetByOverlaps(signif_gr_w_name, biv_genes_overlap)
export(signif_gr_biv, file.path(params$outgenes, "Kumar_2020_H2Aub_diff_bivalent.bed"))
```

# H3K4m3 differential TSS

```{r all-genes-tss-k4-diff, warning=F, message=F}
bw_cond_1 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K4m3_H9_Ni_rep[1-3].hg38.scaled.bw"
  )
bw_cond_2 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K4m3_H9_Pr_rep[1-3].hg38.scaled.bw"
  )

all_hg38_genes <- genes_hg38()
tss <- promoters(all_hg38_genes, upstream = 1500, downstream = 1500)
mcols(tss) <- NULL

c1 <- bw_loci(bw_cond_1, tss)
c2 <- bw_loci(bw_cond_2, tss)

diff <- bw_granges_diff_analysis(c1, c2, "Naive", "Primed", estimate_size_factors = FALSE)

diff_lfc <- lfcShrink(diff, coef="condition_Primed_vs_Naive", type="apeglm")
diff <- results(diff, alpha = params$pval_cutoff)

plotMA(diff_lfc)

signif_gr <- select_signif(diff, c1, p_cutoff = params$pval_cutoff)

hits <- findOverlaps(signif_gr, all_hg38_genes)
signif_gr_w_name <- signif_gr
signif_gr_w_name$name <- "None"
signif_gr_w_name[queryHits(hits), ]$name <- all_hg38_genes[subjectHits(hits), ]$name
export(signif_gr_w_name, file.path(params$outgenes, "Kumar_2020_H3K4m3_diff_tss.bed"))

# Select bivalent ones
signif_gr_biv <- subsetByOverlaps(signif_gr_w_name, biv_genes_overlap)
export(signif_gr_biv, file.path(params$outgenes, "Kumar_2020_H3K4m3_diff_bivalent.bed"))
```

# Genome-wide differential test annotation

## H3K27m3 differential `r params$bin_size`bp bins

```{r k27-diffbins, warning=F, message=F, cache=T}
bw_cond_1 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K27m3_H9_Ni_rep[1-3].hg38.scaled.bw"
  )
bw_cond_2 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K27m3_H9_Pr_rep[1-3].hg38.scaled.bw"
  )

bs <- params$bin_size
c1 <- bw_bins(bw_cond_1, bin_size = bs, genome = "hg38")
c2 <- bw_bins(bw_cond_2, bin_size = bs, genome = "hg38")

diff <- bw_granges_diff_analysis(c1, c2, "Naive", "Primed", estimate_size_factors = FALSE)
diff <- results(diff, alpha = params$pval_cutoff)

mcols(c1) <- NULL
c1$logfc <- diff$log2FoldChange
c1$padj <- diff$padj

p_cutoff <- params$pval_cutoff
c1$score <- 0
c1 <- c1[!is.na(c1$padj), ]
c1[c1$padj <= p_cutoff & c1$logfc > 0, ]$score <- 1 
c1[c1$padj <= p_cutoff & c1$logfc < 0, ]$score <- -1
c1 <- c1[c1$padj <= p_cutoff]
export(c1, file.path(params$outbins, "Kumar_2020_H3K27m3_signif_ni_05.bed"))
```

## H3K4m3 differential `r params$bin_size`bp bins

```{r k4-diffbins, warning=F, message=F, cache=T}
bw_cond_1 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K4m3_H9_Ni_rep[1-3].hg38.scaled.bw"
  )
bw_cond_2 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H3K4m3_H9_Pr_rep[1-3].hg38.scaled.bw"
  )

bs <-  params$bin_size
c1 <- bw_bins(bw_cond_1, bin_size = bs, genome = "hg38")
c2 <- bw_bins(bw_cond_2, bin_size = bs, genome = "hg38")

diff <- bw_granges_diff_analysis(c2, c1, "Primed", "Naive", estimate_size_factors = FALSE)
diff <- results(diff, alpha = params$pval_cutoff)

mcols(c1) <- NULL
c1$logfc <- diff$log2FoldChange
c1$padj <- diff$padj

p_cutoff <- params$pval_cutoff
c1$score <- 0
c1 <- c1[!is.na(c1$padj), ]
c1[c1$padj <= p_cutoff & c1$logfc > 0, ]$score <- 1 
c1[c1$padj <= p_cutoff & c1$logfc < 0, ]$score <- -1
c1 <- c1[c1$padj <= p_cutoff]
export(c1, file.path(params$outbins, "Kumar_2020_H3K4m3_signif_ni_05.bed"))
```

## H2AUb differential `r params$bin_size`bp bins

```{r h2aub-diffbins, warning=F, message=F, cache=T}
bw_cond_1 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H2Aub_H9_Ni_rep[1-3].hg38.scaled.bw"
  )
bw_cond_2 <-
  list.files(
    file.path(params$datadir, "bw/Kumar_2020"),
    full.names = T,
    pattern = "H2Aub_H9_Pr_rep[1-3].hg38.scaled.bw"
  )

bs <- params$bin_size

c1 <- bw_bins(bw_cond_1, bin_size = bs, genome = "hg38")
c2 <- bw_bins(bw_cond_2, bin_size = bs, genome = "hg38")

diff <- bw_granges_diff_analysis(c1, c2, "Naive", "Primed", estimate_size_factors = FALSE)
diff <- results(diff, alpha = params$pval_cutoff)

mcols(c1) <- NULL
c1$logfc <- diff$log2FoldChange
c1$padj <- diff$padj

p_cutoff <- params$pval_cutoff
c1$score <- 0
c1 <- c1[!is.na(c1$padj), ]
c1[c1$padj <= p_cutoff & c1$logfc > 0, ]$score <- 1 
c1[c1$padj <= p_cutoff & c1$logfc < 0, ]$score <- -1
c1 <- c1[c1$padj <= p_cutoff]
export(c1, file.path(params$outbins,"Kumar_2020_H2AUb_signif_ni_05.bed"))
```

# RNA-seq analysis

## Primary analysis

RNA-seq data was analysed by a standard RNA-seq pipeline v2.0, available on nf-core [@ewels2019nf] with mostly default settings. For more information about the specific steps involved in this analysis, refer to the repository documentation: <https://nf-co.re/rnaseq/2.0>, using
the option `--aligner star_rsem`. 

Reference genome used was `hg38`, downloaded from illumina iGenomes: 

<http://igenomes.illumina.com.s3-website-us-east-1.amazonaws.com/Homo_sapiens/UCSC/hg38/Homo_sapiens_UCSC_hg38.tar.gz>


## Gene expression groups

```{r categorize-genes-kumar}
rsem_files <- list(
  naive = list.files(params$rnaseqdir,
                     pattern = "Naive.*genes.results", full.names = T),
  primed = list.files(params$rnaseqdir,
                      pattern = "Primed.*genes.results", full.names = T)
)

counts_naive <- lapply(rsem_files$naive,
                       read.csv,
                       header = T,
                       sep = "\t")

counts_primed <- lapply(rsem_files$primed,
                        read.csv,
                        header = T,
                        sep = "\t")

# Size of the quantile group
size = 0.1

min_qs <- c(0, 0.5 - (size/2), 1-size)
max_qs <- c(0+size, 0.5 + (size/2), 1)

quantile_low <- purrr::partial(
  quantile_group,
  min_q = min_qs[1],
  max_q = max_qs[1],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = params$deciding_stat
)

quantile_med <- purrr::partial(
  quantile_group,
  min_q = min_qs[2],
  max_q = max_qs[2],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = params$deciding_stat
)

quantile_high <- purrr::partial(
  quantile_group,
  min_q = min_qs[3],
  max_q = max_qs[3],
  length_cutoff = params$length_cutoff,
  value_cutoff = params$value_cutoff,
  field = params$deciding_stat
)


naive_top <- map(counts_naive, quantile_high)
naive_med <- map(counts_naive, quantile_med)
naive_low <- map(counts_naive, quantile_low)

primed_top <- map(counts_primed, quantile_high)
primed_med <- map(counts_primed, quantile_med)
primed_low <- map(counts_primed, quantile_low)

export_gene_set(naive_top, file.path("./data/bed/Collier_2017", "Collier_2017_Naive_top.bed"))
export_gene_set(naive_med, file.path("./data/bed/Collier_2017", "Collier_2017_Naive_med.bed"))
export_gene_set(naive_low, file.path("./data/bed/Collier_2017", "Collier_2017_Naive_low.bed"))

export_gene_set(primed_top, file.path("./data/bed/Collier_2017", "Collier_2017_Primed_top.bed"))
export_gene_set(primed_med, file.path("./data/bed/Collier_2017", "Collier_2017_Primed_med.bed"))
export_gene_set(primed_low, file.path("./data/bed/Collier_2017", "Collier_2017_Primed_low.bed"))
```


## Differentially expressed genes

```{r deseq2-kumar-2, warning=FALSE, echo=FALSE, message=FALSE}

ni_pr_diff <- ni_pr_expression_analysis(params$datadir)
ni_ezh2i_diff <- ni_ezh2i_expression_analysis(params$datadir)
pr_ezh2i_diff <- pr_ezh2i_expression_analysis(params$datadir)

dfs <- list(make_df(ni_pr_diff, "Ni_Pr"),
            make_df(ni_ezh2i_diff, "Ni_EZH2i"),
            make_df(pr_ezh2i_diff, "Pr_EZH2i"))

expr_results_all <- reduce(dfs, full_join, by = "gene")

```



```{r deseq2-kumar, warning=FALSE, echo=FALSE, message=FALSE}
counts_file <- file.path(params$datadir, "rnaseq/Collier_2017/rsem.merged.gene_counts.tsv")
counts <- read.table(counts_file, sep = "\t", header = T)

samples <- data.frame(row.names = colnames(counts[, 3:8]), condition = factor(c(rep("Naive", 3), rep("Primed", 3))))
samples$condition <- relevel(samples$condition, ref = "Naive")

counts_only <- round(counts[, 3:8])
rownames(counts_only) <- counts$gene_id

dds <- DESeqDataSetFromMatrix(countData = counts_only,
                              colData = samples,
                              design = ~ condition)
dds <- DESeq(dds)
res <- results(dds, alpha=0.05)

resLFC <- lfcShrink(dds, coef="condition_Primed_vs_Naive", type="apeglm")

plotMA(resLFC)

res_clean <- res[!is.na(res$padj),]


qvals <- quantile(res_clean$baseMean, probs = c(0, 1))
min_fc <- params$fc_cutoff
genes_up <-
  data.frame(res) %>% filter(padj < params$pval_cutoff &
                                        baseMean > qvals[1] &
                                        baseMean < qvals[2] & log2FoldChange > min_fc)
genes_dw <-
  data.frame(res) %>% filter(padj < params$pval_cutoff &
                                        baseMean > qvals[1] &
                                        baseMean < qvals[2] & log2FoldChange < -min_fc)


genes_all <- genes_hg38()

gr_up <- genes_all[genes_all$name %in% rownames(genes_up), ]
gr_dw <- genes_all[genes_all$name %in% rownames(genes_dw), ]

export(gr_up, "./data/bed/Collier_2017/Collier_2017_Naive_up_05_logfc1.bed")
export(gr_dw, "./data/bed/Collier_2017/Collier_2017_Naive_down_05_logfc1.bed")
```

# Aggregate table

Here all the calculated values are merged in a single table.


# Aggregate annotation

Here I build a table where each Gene is annotated with flags:

* Bivalent: Yes or no.
* H3K27m3: Up, down or same (TSS). Up means Naïve is significantly higher than primed.
* H3K4me3: Up, down or same (TSS).
* H2AUb: Up, down or same (TSS).
* Expression: Up, down or same. Again, up means Naïve is higher than primed.
* X-chromosome: Yes or no.

```{r summary-annot-table}

annotate_up_and_down <- function(df, gr, field) {
  df[[field]] <- 0
  names_up <- gr[gr$score > 0, ]$name
  df[names_up, field] <- 1
  names_down <- gr[gr$score < 0, ]$name
  df[names_down, field] <- -1
  df
}

genes_all <- genes_hg38()

annotations <- c("./data/bed/Kumar_2020/Court_2017_bivalent_genes.bed",
                 "./data/bed/Kumar_2020/gene_stats/Kumar_2020_H3K27m3_diff_tss.bed",
                 "./data/bed/Kumar_2020/gene_stats/Kumar_2020_H3K4m3_diff_tss.bed",
                 "./data/bed/Kumar_2020/gene_stats/Kumar_2020_H2Aub_diff_tss.bed",
                 "./data/bed/Collier_2017/Collier_2017_Naive_up_05_logfc1.bed",
                 "./data/bed/Collier_2017/Collier_2017_Naive_down_05_logfc1.bed")

gr_annot <- lapply(annotations, import)

df <- data.frame(genes_all)
rownames(df) <- df$name

df$bivalent <- 0
df[gr_annot[[1]]$name, "bivalent"] <- 1

df <- annotate_up_and_down(df, gr_annot[[2]], "H3K27m3")
df <- annotate_up_and_down(df, gr_annot[[3]], "H3K4m3")
df <- annotate_up_and_down(df, gr_annot[[4]], "H2Aub")

df$expression <- 0
df[gr_annot[[5]]$name, "expression"] <- 1
df[gr_annot[[6]]$name, "expression"] <- -1

df$chrX <- 0
df[df$seqnames == "chrX", "chrX"] <- 1

write.table(df, "./data/bed/Kumar_2020_gene_annotation_table.tsv", row.names = F, sep = "\t", quote = F)

# write.table(df, "./data/bed/Kumar_2020_gene_annotation_table_verbose.tsv", row.names = F, sep = "\t", quote = F)

```
